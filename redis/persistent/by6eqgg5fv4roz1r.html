<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-redis docs-doc-id-persistent/by6eqgg5fv4roz1r">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.4.1">
<title data-rh="true">Redis的AOF是怎么实现的？ | 大话面试</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://open8gu.com/redis/persistent/by6eqgg5fv4roz1r"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="keywords" content="AI, Prompt Engineering, GPT-3, ChatGPT, Midjourney, Learning Prompt, AI, How to use Midjourney, How to use ChatGPT"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-redis-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-redis-current"><meta data-rh="true" property="og:title" content="Redis的AOF是怎么实现的？ | 大话面试"><meta data-rh="true" name="description" content="答题思路"><meta data-rh="true" property="og:description" content="答题思路"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://open8gu.com/redis/persistent/by6eqgg5fv4roz1r"><link data-rh="true" rel="alternate" href="https://open8gu.com/redis/persistent/by6eqgg5fv4roz1r" hreflang="en"><link data-rh="true" rel="alternate" href="https://open8gu.com/redis/persistent/by6eqgg5fv4roz1r" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="大话面试 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="大话面试 Atom Feed">

<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-9QBEXE7W09"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-9QBEXE7W09",{anonymize_ip:!0})</script>












<script src="https://hm.baidu.com/hm.js?89176bed28ac23428d40f42018fd8034" async></script><link rel="stylesheet" href="/assets/css/styles.78b898a5.css">
<link rel="preload" href="/assets/js/runtime~main.ee7b23c9.js" as="script">
<link rel="preload" href="/assets/js/main.f8f7edc1.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}return t}()||function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}(),document.documentElement.setAttribute("data-announcement-bar-initially-dismissed",function(){try{return"true"===localStorage.getItem("docusaurus.announcement.dismiss")}catch(t){}return!1}())</script><div id="__docusaurus">
<div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><div class="announcementBar_mb4j" style="background-color:#fafbfc;color:#091E42" role="banner"><div class="content_knG7 announcementBarContent_xLdY">⭐️ Java程序员必备的八股文小册，助力你在面试中拿个offer！⭐️</div></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="Learning Prompt logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="Learning Prompt logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">大话面试</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/redis/trending/utx7gm7khpfuq3h6">Redis</a><a class="navbar__item navbar__link" href="/cache/trending/sv2p96dqfqppdoca">缓存实战</a><a class="navbar__item navbar__link" href="/concurrent/thread-pool/ftgh02hvumpm3zqg">并发编程</a><a class="navbar__item navbar__link" href="/distribute/distribute-id/ix877lkmxhu60rt1">分布式</a><a class="navbar__item navbar__link" href="/message-queue/kafka/ea448bazulivzdxr">消息队列</a><a class="navbar__item navbar__link" href="/framework/spring/kemtzwgchc3r1dbs">框架八股</a><a class="navbar__item navbar__link" href="/member/info">🧐什么是大话面试？</a></div><div class="navbar__items navbar__items--right"><a href="https://nageoffer.com" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">校&amp;社招没有好项目？<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebarViewport_Xe31"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG menuWithAnnouncementBar_GW3s"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="true" href="/redis/category/热门问题">热门问题</a><button aria-label="Toggle the collapsible sidebar category &#x27;热门问题&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/redis/trending/utx7gm7khpfuq3h6">Redis为什么这么快？</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/redis/trending/fye8babys322xmsm">Redis如何实现到期删除的？</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/redis/trending/drx30l2p8a6klao5">Redis常用内存淘汰策略？</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/redis/trending/zy7ocxktnix5c69n">什么是布隆过滤器？</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/redis/trending/sf9qpv78r4z7mlqd">布隆过滤器容量如何评估？</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/redis/trending/bz7v13grfpfqpeuo">布隆过滤器容量不够用如何解决？</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/redis/trending/rp5mw9n3c6pdla7a">Redis是不是CPU核数越高越好？</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/redis/trending/cu5omslxak0qb98p">如何提升Redis批量访问性能？</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="true" href="/redis/category/数据结构">数据结构</a><button aria-label="Toggle the collapsible sidebar category &#x27;数据结构&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/redis/data-structure/tbsvrxr5qlmqkauh">Redis字符串底层数据结构？</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/redis/data-structure/wpchd5zbg7z9uu67">Redis的压缩列表是什么？</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/redis/data-structure/uo5bw9bha6ba4g1h">Redis的跳表是什么？</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/redis/data-structure/vych53ypih8ksobn">Redis的ZSet底层是怎么实现的？</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/redis/category/数据持久化">数据持久化</a><button aria-label="Toggle the collapsible sidebar category &#x27;数据持久化&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/redis/persistent/oegct3ayo729baqc">Redis宕机数据会丢失么？</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/redis/persistent/fznigr883bhhbp0m">Redis的RDB是怎么实现的？</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/redis/persistent/by6eqgg5fv4roz1r">Redis的AOF是怎么实现的？</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="true" href="/redis/category/高可用篇">高可用篇</a><button aria-label="Toggle the collapsible sidebar category &#x27;高可用篇&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/redis/high-availability/dkpqfbng9omlkdd0">Redis如何实现高可用架构？</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/redis/high-availability/og1nhkabo0audvp3">Redis主从复制的原理是什么？</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/redis/high-availability/vtnqmbeuodyiups4">什么是Redis-Sentinel集群？</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/redis/high-availability/ivylinovg8bmar5x">什么是Redis-Cluster集群？</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/redis/high-availability/amv4qwgw99h8dg6l">Cluster集群可以基于一致性哈希算法么？</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/redis/high-availability/msdvwpgcwom0ukp2">为什么Redis常规架构不适合海量请求？</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/redis/high-availability/qisyfei6svq1ioei">Redis如何应对海量请求？</a></li></ul></li></ul></nav><button type="button" title="Collapse sidebar" aria-label="Collapse sidebar" class="button button--secondary button--outline collapseSidebarButton_PEFL"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_kv0_"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/redis/category/数据持久化"><span itemprop="name">数据持久化</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Redis的AOF是怎么实现的？</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Redis的AOF是怎么实现的？</h1></header><p>作者：程序员马丁</p><p>在线博客：<a href="https://open8gu.com" target="_blank" rel="noopener noreferrer">https://open8gu.com</a></p><div class="theme-admonition theme-admonition-note alert alert--secondary admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 14 16"><path fill-rule="evenodd" d="M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"></path></svg></span>note</div><div class="admonitionContent_S0QG"><p>大话面试，技术同学面试必备的八股文小册，以精彩回答应对深度问题，助力你在面试中拿个offer。</p></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="答题思路">答题思路<a href="#答题思路" class="hash-link" aria-label="Direct link to 答题思路" title="Direct link to 答题思路">​</a></h2><h2 class="anchor anchorWithStickyNavbar_LWe7" id="回答话术">回答话术<a href="#回答话术" class="hash-link" aria-label="Direct link to 回答话术" title="Direct link to 回答话术">​</a></h2><p>AOF 即 <code>Append Only File</code>，它是 Redis 提供的一种持久化机制。</p><p>其原理是每当服务器执行写指令时，将命令追加到 AOF 日志文件。当 Redis 重新启动时，他会在本地启动一个伪客户端，并按顺序重新发送日志中的命令以恢复数据。</p><p>Redis 的 AOF 日志和 MySQL 的 binlog 有点像，当执行一个命令后，数据会先写入 AOF 缓冲区，再写入操作系统缓冲区，最后根据刷盘策略调用 <code>fsync</code> 函数将数据刷入磁盘。Redis 默认提供三种刷盘策略：Always（每个命令后都刷盘）、Everysec（每秒刷一次盘）、No（等到操作系统缓冲区满或定期刷盘）。</p><p>当 AOF 日志越来越大的时候，会触发<!-- -->*<!-- -->*<!-- --> AOF 重写<!-- -->*<!-- -->*<!-- -->。举个例子，假如在 Redis 中对 1 递增了 99 次，那么 AOF 文件会记录一百条命令，但是实际上我们恢复数据的时候只需要一个最终值 100，中间的步骤都是不需要的。基于这个原理，在 Redis 重写的过程中，它会开启一个<strong>子进程</strong>扫描数据库，并生成一个<strong>新的 AOF 文件</strong>去替换旧的文件。这个文件将会比原本的文件精简，并且哪怕这个过程中 Redis 挂了，也不会影响已有的 AOF 文件。</p><p>不过，在子进程进行 AOF 重写的过程中，由于主进程还在不停的接受新的指令，因此它除了需要写自己的 AOF 缓冲区外，还需要将其写到 AOF 重写缓冲区中，以此实现重写过程中的增量数据同步。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="问题详解">问题详解<a href="#问题详解" class="hash-link" aria-label="Direct link to 问题详解" title="Direct link to 问题详解">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1-保存哪些命令">1. 保存哪些命令<a href="#1-保存哪些命令" class="hash-link" aria-label="Direct link to 1. 保存哪些命令" title="Direct link to 1. 保存哪些命令">​</a></h3><p>在 AOF 文件中，只会保存写指令，或者更准确点说，只会保存修改数据的指令。</p><p>比如，我们依次执行了下述指令：</p><ol><li><code>RPUSH list 1 2 3 4</code></li><li><code>LRANGE list 0 -1</code></li><li><code>KEYS *</code></li><li><code>LPUSH list 1</code></li></ol><p>那么，最终只会保存两条：</p><ol><li><code>RPUSH list 1 2 3 4</code></li><li><code>LPUSH list 1</code></li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2-数据的保存格式">2. 数据的保存格式<a href="#2-数据的保存格式" class="hash-link" aria-label="Direct link to 2. 数据的保存格式" title="Direct link to 2. 数据的保存格式">​</a></h3><p>值得注意的是，在 Redis 中执行的命令并不会原模原样的保存到 AOF ，而是以一种比较特殊 <code>$[长度] + [指令]</code> 的格式保存。</p><p>比如，我们执行一个简单的命令 <code>SET name createsequence</code>，那么 AOF 中对应的内容如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">*3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">SET</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">name</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">createsequence</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述命令的含义如下：</p><ol><li><code>*3</code> 表示接下来有 3 个参数；</li><li><code>$3</code> 表示接下来的参数的长度为 3，<code>SET</code> 是命令名称；</li><li><code>$4</code> 表示下一个参数的长度为 4，<code>name</code> 是 Key 的名称；</li><li><code>$12</code> 表示下一个参数的长度为 12，<code>createsequence</code> 是要设置的值。</li></ol><p><img loading="lazy" src="https://oss.open8gu.com/open8gu/778a2b61-6aa6-4ab1-aa7f-f842cebb8a62" alt="image.png" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3-写日志的时机">3. 写日志的时机<a href="#3-写日志的时机" class="hash-link" aria-label="Direct link to 3. 写日志的时机" title="Direct link to 3. 写日志的时机">​</a></h3><p>当 Redis 接收到一条指令的时候，它会先执行指令，然后再写 AOF 日志。</p><p>这个逻辑与我们熟悉的 MySQL 中的 binlog 不同，后者是写前日志（Write Ahead Log, WAL），即先写日志再保存数据，而 AOF 日志则是写后日志，即先保存数据再写日志。</p><p>这种处理方式的优点是：</p><ul><li>可以确保写入 AOF 日志指令都是没有错误的可执行的指令，避免写日志时还需要进行额外的语法/类型检查，或者等出错后回滚日志。</li><li>不因为写日志而阻塞当前指令的执行。</li></ul><p>不过对应的缺点也很明显：</p><ul><li>如果执行完指令实例突然挂了，那 AOF 日志中就不会记录这条指令。</li><li>由于 Redis 的大多数命令都由单个线程执行，因此可能因为写日志而阻塞后一条指令的执行。</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="4-日志的刷盘策略">4. 日志的刷盘策略<a href="#4-日志的刷盘策略" class="hash-link" aria-label="Direct link to 4. 日志的刷盘策略" title="Direct link to 4. 日志的刷盘策略">​</a></h3><p>实际上，将指令数据写入磁盘的时候，并不是一步完成的：</p><ol><li>当执行了写指令后，数据首先被写入 Redis 自己的 AOF 缓冲区；</li><li>随后，Redis 会调用操作系统的 <code>write</code> 函数，将数据从 AOF 缓冲区写入操作系统缓冲区；</li><li>最后，再由 Redis 调用 <code>fsync</code> 函数或操作系统自己刷盘，让内核缓冲区中的数据真正写入磁盘。</li></ol><p>第三步即我们通常说的“<strong>日志刷盘</strong>”。在日志真正的刷到磁盘之前，数据仍然仅保存在内存里，此时一旦服务器宕机，数据将会永久性的丢失。因此，何时刷盘是整个持久化流程的关键点。</p><p>在 MySQL 中，我们可以通过 <code>binlog_sync</code> 来指定 binlog 的刷盘策略，而在 Redis 中，我们可以通过 <code>appendfsync</code> 配置项指定 AOF 日志的的刷盘策略：</p><ul><li><code>AOF_FSYNC_NO</code> ：AOF 缓冲区有数据时（即执行一个命令后），调用 <code>write</code>函数写入操作系统缓冲区，然后操作系统定期（在 Linux 中通常是 30 秒）或缓冲区满后再自动写入磁盘。</li><li><code>AOF_FSYNC_EVERYSEC</code> ：AOF 缓冲区有数据时（即执行一个命令后），调用 <code>write</code>函数写入操作系统缓冲区，然后每一秒钟调用一次 <code>fsync</code> 将数据写入磁盘。</li><li><code>AOF_FSYNC_ALWAYS</code> ：AOF 缓冲区有数据时（即执行一个命令后），立刻调用 <code>fsync</code> 将数据写入磁盘。</li></ul><p><img loading="lazy" src="https://oss.open8gu.com/open8gu/396b61b4-4946-4077-ae5a-dce187f5c7e3" alt="image.png" class="img_ev3q"></p><p>这三种配置方式各有优劣，它们会很大程度上的影响 Redis 的性能：</p><table><thead><tr><th>指令</th><th>时机</th><th>性能</th><th>宕机时丢失的数据</th></tr></thead><tbody><tr><td><code>AOF_FSYNC_NO</code></td><td>不主动刷盘，由操作系统自己决定刷盘时机</td><td>高</td><td>所有未写入磁盘的数据</td></tr><tr><td><code>AOF_FSYNC_EVERYSEC</code></td><td>每秒保存一次</td><td>中</td><td>一秒内的数据</td></tr><tr><td><code>AOF_FSYNC_ALWAYS</code></td><td>每个命令执行后保存一次</td><td>低</td><td>一条指令的数据</td></tr></tbody></table><p>总的来说，核心问题在于<strong>如何取舍可靠性与性能</strong>：</p><ul><li>如果你的系统对数据可靠性要求极高，不允许数据丢失，那么你应该选择 <code>ALWAYS</code>。</li><li>如果你的系统更在乎性能，而不在意丢失一些数据，那么你可以选择 <code>NO</code>。</li><li>如果你想要在两者间取得平衡，那么你可以选择 <code>EVERSEC</code>。</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5-aof-重写">5. AOF 重写<a href="#5-aof-重写" class="hash-link" aria-label="Direct link to 5. AOF 重写" title="Direct link to 5. AOF 重写">​</a></h3><h4 class="anchor anchorWithStickyNavbar_LWe7" id="51-实现原理">5.1. 实现原理<a href="#51-实现原理" class="hash-link" aria-label="Direct link to 5.1. 实现原理" title="Direct link to 5.1. 实现原理">​</a></h4><p>随着写入操作的进行，AOF 文件会变得越来越大，而这其中的大多数数据是没必要保存的。</p><p>比如，你把 1 递增到 100，那么最终 AOF 会记录这一过程中的全部 100 条指令。然而实际上我们只需要最终的值 100 即可。</p><p>因此，AOF 提供了一种重写机制，即当 AOF 文件膨胀到一定程度时，Redis 将直接重新扫描当前数据库中的数据，然后把它们重写到一个新 AOF 文件中，并替换旧的 AOF 文件，这个新的 AOF 文件会比原本的文件更小。</p><p>在这个过程中，Redis 实际上完全不会重新读取原有的 AOF 文件。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="52-触发条件">5.2. 触发条件<a href="#52-触发条件" class="hash-link" aria-label="Direct link to 5.2. 触发条件" title="Direct link to 5.2. 触发条件">​</a></h4><p>在 2.4 版本以后，当你开启 AOF 功能，Redis 会在满足下述三个条件的时候自动触发 AOF 重写：</p><ul><li>当前没有正在执行的 AOF 重写或 RDB 生成操作。</li><li>当前的 AOF 文件大于 <code>server.aof_rewrite_min_size</code> 配置。</li><li>当前 AOF 的文件大小增幅达到设置的比例（比如比上一次重写后的文件大了 50%）。</li></ul><p>除此之外，你也可以可以通过 <code>BGREWRITEAOF</code> 命令手动触发 AOF 重写。</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="53-后台重写">5.3. 后台重写<a href="#53-后台重写" class="hash-link" aria-label="Direct link to 5.3. 后台重写" title="Direct link to 5.3. 后台重写">​</a></h4><p>作为一个非常重的 IO 操作，AOF 重写会长时间的阻塞线程，因此 Reids 会通过操作系统的 <code>fork</code> 函数分离出一个子进程 <code>bgrewriteaof</code> 来完成。</p><p>使用子进程的好处在于：</p><ul><li>子进程进行 AOF 重写时，主进程可以正常执行，避免阻塞。</li><li>由于子进程带有主进程的数据副本，因此不需要像线程通过加锁控制对数据的访问。</li></ul><h4 class="anchor anchorWithStickyNavbar_LWe7" id="54-增量数据的同步">5.4. 增量数据的同步<a href="#54-增量数据的同步" class="hash-link" aria-label="Direct link to 5.4. 增量数据的同步" title="Direct link to 5.4. 增量数据的同步">​</a></h4><p>由于 AOF 重写基于父子进程，因此也带来一个问题：当子进程进行 AOF 重写时，主进程仍然还在接受指令修改数据，因此重写的 AOF 文件数据与实时数据就可能不一致。</p><p>对此，以 7.0 版本为分界线，Redis 采用了不同的处理方式：</p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="541-70-版本之前">5.4.1. 7.0 版本之前<a href="#541-70-版本之前" class="hash-link" aria-label="Direct link to 5.4.1. 7.0 版本之前" title="Direct link to 5.4.1. 7.0 版本之前">​</a></h5><p>在 7.0 之前，Redis 采用让主进程同时写两份 AOF 文件的方式来处理这个问题。</p><p>简单的来说，当子进程在进行 AOF 重写时，如果主进程接受了一个写指令，那么它在执行后，既要将这个指令追加到 AOF 缓冲区中，也需要将其加入 AOF 重写缓存中，相当于同时写两份文件。</p><p>当子进程完成 AOF 重写后，它会向父进程发送完成信号，此时父进程将阻塞的将 AOF 重写缓存区中的数据全部写入新的 AOF 文件中，然后使用新的 AOF 文件覆盖旧的 AOF 文件。至此， AOF 重写就完成了。</p><h5 class="anchor anchorWithStickyNavbar_LWe7" id="542-70-版本之后">5.4.2. 7.0 版本之后<a href="#542-70-版本之后" class="hash-link" aria-label="Direct link to 5.4.2. 7.0 版本之后" title="Direct link to 5.4.2. 7.0 版本之后">​</a></h5><p>在 7.0 之后，当开始 AOF 重写的时候，主进程直接将增量数据写到一个全新的增量 AOF 文件中，等到主进程重写完 AOF，主进程再将增量 AOF 文件与重写后的 AOF 文件合并，并替换旧的 AOF 文件。</p><p>相比起 7.0 之前，对于同一个增量命令，Redis 只需写一次即可。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="6-数据的恢复">6. 数据的恢复<a href="#6-数据的恢复" class="hash-link" aria-label="Direct link to 6. 数据的恢复" title="Direct link to 6. 数据的恢复">​</a></h3><p>当 Redis 重新启动时，它会创建一个本地的伪客户端，这个客户端将会读取 AOF 日志，并且在还原出命令后发送给 Redis 服务端，直到全部的命令都执行完毕为止。</p><p>另外，根据官网文档，如果 Redis 在写 AOF 日志的过程中宕机，或者由于磁盘已满等不可抗力最终导致 AOF 日志出错，那么当重启时，Redis 会丢弃最后一个写入失败的指定，或者如果情况更糟糕，则可以通过 <code>redis-check-aof</code>工具尝试修复它。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="7-混合持久化">7. 混合持久化<a href="#7-混合持久化" class="hash-link" aria-label="Direct link to 7. 混合持久化" title="Direct link to 7. 混合持久化">​</a></h3><p>由于通过 AOF 恢复数据相对比较耗时，因此 Redis 在 4.0 以后允许通过 <code>aof‐use‐rdb‐preamble</code> 配置开启混合持久化。</p><p>当 AOF 重写时，它将会先生成当前时间的 RDB 快照，然后将其写入新的 AOF 文件，接着再把增量数据追加到这个新 AOF 文件中。如此一来，当 Redis 通过 AOF 文件恢复数据时，将会先加载 RDB，然后再重放后半部分的增量数据。这样就可以大幅度提高数据恢复的速度。</p></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/redis/persistent/fznigr883bhhbp0m"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Redis的RDB是怎么实现的？</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/redis/category/高可用篇"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">高可用篇</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_jeP5 thin-scrollbar theme-doc-toc-desktop"><div class="margin--md"></div><h3 class="padding-left--md padding-top--md margin-bottom--none" style="text-transform:uppercase;font-size:0.75em;color:var(--ifm-color-emphasis-700);letter-spacing:0.5px">Table of Contents</h3><ul class="table-of-contents table-of-contents__left-border"><li><a href="#答题思路" class="table-of-contents__link toc-highlight">答题思路</a></li><li><a href="#回答话术" class="table-of-contents__link toc-highlight">回答话术</a></li><li><a href="#问题详解" class="table-of-contents__link toc-highlight">问题详解</a><ul><li><a href="#1-保存哪些命令" class="table-of-contents__link toc-highlight">1. 保存哪些命令</a></li><li><a href="#2-数据的保存格式" class="table-of-contents__link toc-highlight">2. 数据的保存格式</a></li><li><a href="#3-写日志的时机" class="table-of-contents__link toc-highlight">3. 写日志的时机</a></li><li><a href="#4-日志的刷盘策略" class="table-of-contents__link toc-highlight">4. 日志的刷盘策略</a></li><li><a href="#5-aof-重写" class="table-of-contents__link toc-highlight">5. AOF 重写</a></li><li><a href="#6-数据的恢复" class="table-of-contents__link toc-highlight">6. 数据的恢复</a></li><li><a href="#7-混合持久化" class="table-of-contents__link toc-highlight">7. 混合持久化</a></li></ul></li></ul></div></div></div></div></main></div></div></div>
<script src="/assets/js/runtime~main.ee7b23c9.js"></script>
<script src="/assets/js/main.f8f7edc1.js"></script>
</body>
</html>